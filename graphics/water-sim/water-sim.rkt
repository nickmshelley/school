#lang racket
(require racket/gui
         sgl
         sgl/gl
         sgl/gl-vectors
         "sgl-vectors-utils.rkt")

(struct u-vec (h u v) #:mutable #:transparent)
(struct point (x z u v normal cur-vec right-vec up-vec) #:mutable #:transparent)

(define ELEMS 26)
(define SPREAD 5)
(define START-HEIGHT 10)
(define delta (/ (* 2 SPREAD) ELEMS))
(define delta-t .01)
(define g -9.8)

(define (vector-from-point p)
  (gl-float-vector (point-x p)
                   (+ START-HEIGHT (u-vec-h (point-cur-vec p)))
                   (point-z p)))

(define (reset-normal p)
  (set-point-normal! p #f))

(define matrix
  (for/list ([i (in-range ELEMS)]
             [x (in-range (- SPREAD) SPREAD delta)])
    (for/list ([j (in-range ELEMS)]
               [z (in-range (- SPREAD) SPREAD delta)])
      (point x z 0 0 #f (u-vec 1 0 0) (u-vec 1 0 0) (u-vec 1 0 0)))))

(define (resize w h)
  (gl-matrix-mode 'projection)
  (gl-load-identity)
  (gluPerspective 45 1 .1 100)
  (gl-matrix-mode 'modelview)
  (gl-viewport 0 0 w h)
  #t)

(define (init-opengl)
  (gl-clear-color 1 1 1 1)
  
  (gl-light-v 'light0 'position (gl-float-vector 1 1 1 0))
  
  (gl-shade-model 'smooth)
  (gl-enable 'lighting)
  (gl-enable 'light0)
  (gl-depth-func 'lequal)
  (gl-enable 'depth-test))

(define (matrix-ref matrix i j)
  (list-ref (list-ref matrix i) j))

(set-point-cur-vec! (matrix-ref matrix (/ ELEMS 2) (/ ELEMS 2)) (u-vec 1.002 0 0))

(define (reset-normals mat)
  (for* ([i (in-range ELEMS)]
         [j (in-range ELEMS)])
    (reset-normal (matrix-ref mat i j))))

(define (draw-matrix)
  (reset-normals matrix)
  (gl-material-v 'front 'ambient-and-diffuse (gl-float-vector .3 .4 .9 1))
  (gl-begin 'triangle-strip)
  (for* ([i (in-range (sub1 ELEMS))] 
         [j (in-range ELEMS)])
    (define zero-vector (gl-float-vector 0 0 0))
    (define center-point (matrix-ref matrix i j))
    (define top-point (matrix-ref matrix (add1 i) j))
    (define center (vector-from-point center-point))
    (define top (vector-from-point top-point))
    (define top-top (if (< i (- ELEMS 2))
                        (vector-from-point (matrix-ref matrix (+ 2 i) j))
                        #f))
    (define left (if (> j 0)
                     (vector-from-point (matrix-ref matrix i (sub1 j)))
                     #f))
    (define top-top-left (if (and (< i (- ELEMS 2)) (> 0 j))
                             (vector-from-point (matrix-ref matrix (+ 2 i) (sub1 j)))
                             #f))
    (define right (if (< j (sub1 ELEMS))
                      (vector-from-point (matrix-ref matrix i (add1 j)))
                      #f))
    (define top-right (if (< j (sub1 ELEMS))
                          (vector-from-point (matrix-ref matrix (add1 i) (add1 j)))
                          #f))
    (define bottom (if (> i 0)
                       (vector-from-point (matrix-ref matrix (sub1 i) j))
                       #f))
    (define top-left (if (> j 0)
                         (vector-from-point (matrix-ref matrix (add1 i) (sub1 j)))
                         #f))
    (define bottom-right (if (and (> i 0) (< j (sub1 ELEMS)))
                             (vector-from-point (matrix-ref matrix (sub1 i) (add1 j)))
                             #f))
    (define center-normal (if (point-normal center-point)
                              (point-normal center-point)
                              (normalize (add-vectors (list (normal-from-vectors center left top-left)
                                                            (normal-from-vectors center top-left top)
                                                            (normal-from-vectors center top right)
                                                            (normal-from-vectors center right bottom-right)
                                                            (normal-from-vectors center bottom-right bottom)
                                                            (normal-from-vectors center bottom left))))))
    (gl-normal-v (point-up center-normal))
    (gl-vertex-v center)
    (define top-normal (if (point-normal top-point)
                           (point-normal top-point)
                           (normalize (add-vectors (list (normal-from-vectors top top-left top-top-left)
                                                         (normal-from-vectors top top-top-left top-top)
                                                         (normal-from-vectors top top-top top-right)
                                                         (normal-from-vectors top top-right right)
                                                         (normal-from-vectors top right center)
                                                         (normal-from-vectors top center top-left))))))
    (gl-normal-v (point-up top-normal))
    (gl-vertex-v top))
  (gl-end))

(define (draw-opengl)
  (gl-clear 'color-buffer-bit 'depth-buffer-bit)
  (gl-push-matrix)
  (gluLookAt -7 (+ 5 START-HEIGHT) 16
             0 START-HEIGHT 0
             0 1 0)
  (draw-matrix)
  (gl-pop-matrix)
  (gl-end))

(define (f-from-u vec)
  (define h (u-vec-h vec))
  (define u (u-vec-u vec))
  (define v (u-vec-v vec))
  (u-vec (* u h)
         (+ (* (expt u 2) h) (* 1/2 g (expt h 2)))
         (* u v h)))

(define (g-from-u vec)
  (define h (u-vec-h vec))
  (define u (u-vec-u vec))
  (define v (u-vec-v vec))
  (u-vec (* v h)
         (* u v h)
         (+ (* (expt v 2) h) (* 1/2 g (expt h 2)))))

(define (calculate-half-step cur-u next-u cur-force next-force)
  (- (* 1/2 (+ next-u cur-u))
     (/ (* 1/2 delta-t (- next-u cur-u)) delta)))

(define (horizontal-half-step cur-point right-point)
  (define cur-u (point-cur-vec cur-point))
  (define cur-f (f-from-u cur-u))
  (define right-u (point-cur-vec right-point))
  (define right-f (f-from-u right-u))
  (define new-h (calculate-half-step (u-vec-h cur-u)
                                     (u-vec-h right-u)
                                     (u-vec-h cur-f)
                                     (u-vec-h right-f)))
  (define new-u (calculate-half-step (u-vec-u cur-u)
                                     (u-vec-u right-u)
                                     (u-vec-u cur-f)
                                     (u-vec-u right-f)))
  (define new-v (calculate-half-step (u-vec-v cur-u)
                                     (u-vec-v right-u)
                                     (u-vec-v cur-f)
                                     (u-vec-v right-f)))
  (set-point-right-vec! cur-point (u-vec new-h new-u new-v)))

(define (vertical-half-step cur-point up-point)
  (define cur-u (point-cur-vec cur-point))
  (define cur-g (g-from-u cur-u))
  (define up-u (point-cur-vec up-point))
  (define up-g (g-from-u up-u))
  (define new-h (calculate-half-step (u-vec-h cur-u)
                                     (u-vec-h up-u)
                                     (u-vec-h cur-g)
                                     (u-vec-h up-g)))
  (define new-u (calculate-half-step (u-vec-u cur-u)
                                     (u-vec-u up-u)
                                     (u-vec-u cur-g)
                                     (u-vec-u up-g)))
  (define new-v (calculate-half-step (u-vec-v cur-u)
                                     (u-vec-v up-u)
                                     (u-vec-v cur-g)
                                     (u-vec-v up-g)))
  (set-point-up-vec! cur-point (u-vec new-h new-u new-v)))

(define (half-step)
  (for* ([j (in-range ELEMS)]
         [i (in-range ELEMS)])
    (define cur-point (matrix-ref matrix i j))
    (define right-point (if (< i (sub1 ELEMS))
                            (matrix-ref matrix (add1 i) j)
                            #f))
    (define up-point (if (< j (sub1 ELEMS))
                         (matrix-ref matrix i (add1 j))
                         #f))
    (when right-point (horizontal-half-step cur-point right-point))
    (when up-point (vertical-half-step cur-point up-point))))

(define (calculate-full-step cur-u next-f prev-f next-g prev-g)
  (- cur-u
     (/ (* delta-t (- next-f prev-f)) delta)
     (/ (* delta-t (- next-g prev-g)) delta)))

(define (perform-full-step cur-point left-point down-point )
  (define cur-u (point-cur-vec cur-point))
  (define next-f (f-from-u (point-right-vec cur-point)))
  (define prev-f (f-from-u (point-right-vec left-point)))
  (define next-g (g-from-u (point-up-vec cur-point)))
  (define prev-g (g-from-u (point-up-vec down-point)))
  (define new-h (calculate-full-step (u-vec-h cur-u)
                                     (u-vec-h next-f)
                                     (u-vec-h prev-f)
                                     (u-vec-h next-g)
                                     (u-vec-h prev-g)))
  (define new-u (calculate-full-step (u-vec-u cur-u)
                                     (u-vec-u next-f)
                                     (u-vec-u prev-f)
                                     (u-vec-u next-g)
                                     (u-vec-u prev-g)))
  (define new-v (calculate-full-step (u-vec-v cur-u)
                                     (u-vec-v next-f)
                                     (u-vec-v prev-f)
                                     (u-vec-v next-g)
                                     (u-vec-v prev-g)))
  (set-point-cur-vec! cur-point (u-vec new-h new-u new-v)))

(define (full-step)
  (for* ([j (in-range ELEMS)]
         [i (in-range ELEMS)])
    (define cur-point (matrix-ref matrix i j))
    (define h (u-vec-h (point-cur-vec cur-point)))
    (define zero-point (point 0 0 0 0 0 (u-vec h 0 0) (u-vec h 0 0) (u-vec h 0 0)))
    (define left-point (if (> i 0)
                           (matrix-ref matrix (sub1 i) j)
                           zero-point))
    (define down-point (if (> j 0)
                           (matrix-ref matrix i (sub1 j))
                           zero-point))
    (perform-full-step cur-point left-point down-point)))

(define (calculate-matrix)
  (half-step)
  (full-step))

(define my-canvas%
  (class* canvas% ()
    (inherit refresh with-gl-context swap-gl-buffers)
    
    (define/public (gl-init)
      (with-gl-context
       (lambda ()
         (init-opengl))))
    
    (define/override (on-paint)
      (with-gl-context
       (lambda ()
         (calculate-matrix)
         (draw-opengl)
         (swap-gl-buffers)
         (queue-callback (lambda x (send this refresh)) #f))))
    
    (define/override (on-size width height)
      (with-gl-context
       (lambda ()
         (resize width height))))
    
    (super-instantiate () (style '(gl)))))

(define win (new frame% (label "OpenGl Test") (min-width 800) (min-height
                                                               800)))
(define gl  (new my-canvas% (parent win)))

(send gl gl-init)
(send win show #t)