#lang racket
(require racket/gui
         sgl
         sgl/gl
         sgl/gl-vectors
         "sgl-vectors-utils.rkt")

(struct u-vec (h u v) #:mutable #:transparent)
(struct point (x z normal cur-vec right-vec up-vec) #:mutable #:transparent)

(define ELEMS 32)
(define SPREAD 5)
(define START-HEIGHT 5)
(define delta (/ (* 2 SPREAD) ELEMS))

;these values are updated from gui initial values at bottom
(define delta-t .03)
(define g 5.0)

(define (vector-from-point p)
  (gl-float-vector (point-x p)
                   (+ (u-vec-h (point-cur-vec p)))
                   (point-z p)))

(define (reset-normal p)
  (set-point-normal! p #f))

(define (empty-matrix)
  (for/list ([i (in-range ELEMS)]
             [x (in-range (- SPREAD) SPREAD delta)])
    (for/list ([j (in-range ELEMS)]
               [z (in-range (- SPREAD) SPREAD delta)])
      (point x z #f (u-vec START-HEIGHT 0 0) (u-vec START-HEIGHT 0 0) (u-vec START-HEIGHT 0 0)))))

(define matrix (empty-matrix))

(define (reset)
  (set! matrix (empty-matrix)))

(define (resize w h)
  (gl-matrix-mode 'projection)
  (gl-load-identity)
  (gluPerspective 45 1 .1 100)
  (gl-matrix-mode 'modelview)
  (gl-viewport 0 0 w h)
  #t)

(define (init-opengl)
  (gl-clear-color 1 1 1 1)
  
  (gl-light-v 'light0 'position (gl-float-vector 1 1 1 0))
  
  (gl-shade-model 'smooth)
  (gl-enable 'lighting)
  (gl-enable 'light0)
  (gl-depth-func 'lequal)
  (gl-enable 'depth-test))

; i and j are x and y
(define (matrix-ref matrix i j)
  (list-ref (list-ref matrix j) i))

(define (in-range? num)
  (and (>= num 0) (< num ELEMS)))

(define (do-drop x-ratio y-ratio radius height)
  (define x (inexact->exact (round (* ELEMS x-ratio))))
  (define y (inexact->exact (round (* ELEMS y-ratio))))
  (for* ([i (in-range (- x radius) (+ x radius))]
         [j (in-range (- y radius) (+ y radius))])
    (when (and (in-range? i) (in-range? j))
      (set-point-cur-vec! (matrix-ref matrix i j) (u-vec (+ START-HEIGHT height) 0 0)))))

(define (reset-normals mat)
  (for* ([i (in-range ELEMS)]
         [j (in-range ELEMS)])
    (reset-normal (matrix-ref mat i j))))

(define (draw-matrix)
  (reset-normals matrix)
  (gl-material-v 'front 'ambient-and-diffuse (gl-float-vector .3 .4 .9 1))
  (for ([j (in-range 1 (sub1 ELEMS))])
    (gl-begin 'triangle-strip)
    (for ([i (in-range 1 ELEMS)])
      (define zero-vector (gl-float-vector 0 0 0))
      (define center-point (matrix-ref matrix i j))
      (define top-point (matrix-ref matrix i (add1 j)))
      (define center (vector-from-point center-point))
      (define top (vector-from-point top-point))
      (define top-top (if (< j (- ELEMS 2))
                          (vector-from-point (matrix-ref matrix i (+ 2 j)))
                          #f))
      (define left (if (> i 1)
                       (vector-from-point (matrix-ref matrix (sub1 i) j))
                       #f))
      (define top-top-left (if (and (< j (- ELEMS 2)) (> i 1))
                               (vector-from-point (matrix-ref matrix (sub1 i) (+ 2 j)))
                               #f))
      (define right (if (< i (sub1 ELEMS))
                        (vector-from-point (matrix-ref matrix (add1 i)  j))
                        #f))
      (define top-right (if (< i (sub1 ELEMS))
                            (vector-from-point (matrix-ref matrix (add1 i) (add1 j)))
                            #f))
      (define bottom (if (> j 1)
                         (vector-from-point (matrix-ref matrix i (sub1 j)))
                         #f))
      (define top-left (if (> i 1)
                           (vector-from-point (matrix-ref matrix (sub1 i) (add1 j)))
                           #f))
      (define bottom-right (if (and (> j 1) (< i (sub1 ELEMS)))
                               (vector-from-point (matrix-ref matrix (add1 i) (sub1 j)))
                               #f))
      (define center-normal (if (point-normal center-point)
                                (point-normal center-point)
                                (normalize (add-vectors (list (normal-from-vectors center left top-left)
                                                              (normal-from-vectors center top-left top)
                                                              (normal-from-vectors center top right)
                                                              (normal-from-vectors center right bottom-right)
                                                              (normal-from-vectors center bottom-right bottom)
                                                              (normal-from-vectors center bottom left))))))
      (gl-normal-v (point-up center-normal))
      (gl-vertex-v center)
      (define top-normal (if (point-normal top-point)
                             (point-normal top-point)
                             (normalize (add-vectors (list (normal-from-vectors top top-left top-top-left)
                                                           (normal-from-vectors top top-top-left top-top)
                                                           (normal-from-vectors top top-top top-right)
                                                           (normal-from-vectors top top-right right)
                                                           (normal-from-vectors top right center)
                                                           (normal-from-vectors top center top-left))))))
      (gl-normal-v (point-up top-normal))
      (gl-vertex-v top))
    (gl-end)))

(define (draw-opengl)
  (gl-clear 'color-buffer-bit 'depth-buffer-bit)
  (gl-push-matrix)
  (gluLookAt -7 (+ 5 START-HEIGHT) 16
             0 START-HEIGHT 0
             0 1 0)
  (draw-matrix)
  (gl-pop-matrix)
  (gl-end))

(define (f-from-u vec)
  (define h (u-vec-h vec))
  (define u (/ (u-vec-u vec) h))
  (define v (/ (u-vec-v vec) h))
  (u-vec (* u h)
         (+ (* (expt u 2) h) (* 1/2 g (expt h 2)))
         (* u v h)))

(define (g-from-u vec)
  (define h (u-vec-h vec))
  (define u (/ (u-vec-u vec) h))
  (define v (/ (u-vec-v vec) h))
  (u-vec (* v h)
         (* u v h)
         (+ (* (expt v 2) h) (* 1/2 g (expt h 2)))))

(define (calculate-half-step cur-u next-u cur-force next-force)
  (- (* 1/2 (+ next-u cur-u))
     (/ (* 1/2 delta-t (- next-force cur-force)) delta)))

(define (horizontal-half-step cur-point right-point)
  (define cur-u (point-cur-vec cur-point))
  (define cur-f (f-from-u cur-u))
  (define right-u (point-cur-vec right-point))
  (define right-f (f-from-u right-u))
  (define new-h (calculate-half-step (u-vec-h cur-u)
                                     (u-vec-h right-u)
                                     (u-vec-h cur-f)
                                     (u-vec-h right-f)))
  (define new-u (calculate-half-step (u-vec-u cur-u)
                                     (u-vec-u right-u)
                                     (u-vec-u cur-f)
                                     (u-vec-u right-f)))
  (define new-v (calculate-half-step (u-vec-v cur-u)
                                     (u-vec-v right-u)
                                     (u-vec-v cur-f)
                                     (u-vec-v right-f)))
  (set-point-right-vec! cur-point (u-vec new-h new-u new-v)))

(define (vertical-half-step cur-point up-point)
  (define cur-u (point-cur-vec cur-point))
  (define cur-g (g-from-u cur-u))
  (define up-u (point-cur-vec up-point))
  (define up-g (g-from-u up-u))
  (define new-h (calculate-half-step (u-vec-h cur-u)
                                     (u-vec-h up-u)
                                     (u-vec-h cur-g)
                                     (u-vec-h up-g)))
  (define new-u (calculate-half-step (u-vec-u cur-u)
                                     (u-vec-u up-u)
                                     (u-vec-u cur-g)
                                     (u-vec-u up-g)))
  (define new-v (calculate-half-step (u-vec-v cur-u)
                                     (u-vec-v up-u)
                                     (u-vec-v cur-g)
                                     (u-vec-v up-g)))
  (set-point-up-vec! cur-point (u-vec new-h new-u new-v)))

;updated from gui initial value at bottom
(define factor .5)
(define (scale p)
  (define cur (point-cur-vec p))
  (define right (point-right-vec p))
  (define up (point-up-vec p))
  (point 0 0 0
         (u-vec (u-vec-h cur)
                (* factor (u-vec-u cur))
                (* factor (u-vec-v cur)))
         (u-vec (u-vec-h right)
                (* factor (u-vec-u right))
                (* factor (u-vec-v right)))
         (u-vec (u-vec-h up)
                (* factor (u-vec-u up))
                (* factor (u-vec-v up)))))
(define (half-step)
  (for* ([i (in-range ELEMS)]
         [j (in-range ELEMS)])
    (define cur-point (matrix-ref matrix i j))
    (define h (u-vec-h (point-cur-vec cur-point)))
    (define zero-point (point 0 0 0 (u-vec h 0 0) (u-vec h 0 0) (u-vec h 0 0)))
    (define right-point (if (< i (sub1 ELEMS))
                            (matrix-ref matrix (add1 i) j)
                            (scale cur-point)))
    (define up-point (if (< j (sub1 ELEMS))
                         (matrix-ref matrix i (add1 j))
                         (scale cur-point)))
    (horizontal-half-step cur-point right-point)
    (vertical-half-step cur-point up-point)))

(define (calculate-full-step cur-u next-f prev-f next-g prev-g)
  (- cur-u
     (/ (* delta-t (- next-f prev-f)) delta)
     (/ (* delta-t (- next-g prev-g)) delta)))

(define (perform-full-step cur-point left-point down-point )
  (define cur-u (point-cur-vec cur-point))
  (define next-f (f-from-u (point-right-vec cur-point)))
  (define prev-f (f-from-u (point-right-vec left-point)))
  (define next-g (g-from-u (point-up-vec cur-point)))
  (define prev-g (g-from-u (point-up-vec down-point)))
  (define new-h (calculate-full-step (u-vec-h cur-u)
                                     (u-vec-h next-f)
                                     (u-vec-h prev-f)
                                     (u-vec-h next-g)
                                     (u-vec-h prev-g)))
  (define new-u (calculate-full-step (u-vec-u cur-u)
                                     (u-vec-u next-f)
                                     (u-vec-u prev-f)
                                     (u-vec-u next-g)
                                     (u-vec-u prev-g)))
  (define new-v (calculate-full-step (u-vec-v cur-u)
                                     (u-vec-v next-f)
                                     (u-vec-v prev-f)
                                     (u-vec-v next-g)
                                     (u-vec-v prev-g)))
  (set-point-cur-vec! cur-point (u-vec new-h new-u new-v)))

(define (full-step)
  (for* ([j (in-range ELEMS)]
         [i (in-range ELEMS)])
    (define cur-point (matrix-ref matrix i j))
    (define h (u-vec-h (point-cur-vec cur-point)))
    (define zero-point (point 0 0 0 (u-vec h 0 0) (u-vec h 0 0) (u-vec h 0 0)))
    (define left-point (if (> i 0)
                           (matrix-ref matrix (sub1 i) j)
                           (scale cur-point)))
    (define down-point (if (> j 0)
                           (matrix-ref matrix i (sub1 j))
                           (scale cur-point)))
    (perform-full-step cur-point left-point down-point)))

(define (calculate-matrix)
  (half-step)
  (full-step))

(define my-canvas%
  (class* canvas% ()
    (inherit refresh with-gl-context swap-gl-buffers)
    
    (define/public (gl-init)
      (with-gl-context
       (lambda ()
         (init-opengl))))
    
    (define/override (on-paint)
      (with-gl-context
       (lambda ()
         (calculate-matrix)
         (draw-opengl)
         (swap-gl-buffers)
         (queue-callback (lambda x (send this refresh)) #f))))
    
    (define/override (on-size width height)
      (with-gl-context
       (lambda ()
         (resize width height))))
    
    (super-instantiate () (style '(gl)))))

(define (update-values time absorb grav)
  (set! delta-t time)
  (set! factor absorb)
  (set! g grav)
  (reset))

(define win (new frame% (label "OpenGl Test")))
(define gl  (new my-canvas% (parent win) (min-width 800) (min-height 800)))
(define main-panel (new horizontal-panel% (parent win)
                     (alignment '(center center)) (stretchable-height #f)))
(define update-panel (new vertical-panel% (parent main-panel)
                          (alignment '(center center))))
(define time-field (instantiate text-field% ("time step" update-panel) (init-value ".03")))
(define absorbance-field (instantiate text-field% ("wall absorbance" update-panel) (init-value ".5")))
(define gravity-field (instantiate text-field% ("gravity" update-panel) (init-value "5")))
(instantiate button% ("Update" main-panel (lambda (b e) (update-values (string->number (send time-field get-value))
                                                                       (string->number (send absorbance-field get-value))
                                                                       (string->number (send gravity-field get-value)))))
                                             (stretchable-width #f) (stretchable-height #t))
(define drop-panel (new vertical-panel% (parent main-panel)
                          (alignment '(center center))))
(define x-field (instantiate text-field% ("x ratio" drop-panel) (init-value ".5")))
(define y-field (instantiate text-field% ("y ratio" drop-panel) (init-value ".5")))
(define radius-field (instantiate text-field% ("radius" drop-panel) (init-value "2")))
(define height-field (instantiate text-field% ("height" drop-panel) (init-value "2")))
(instantiate button% ("Drop" main-panel (lambda (b e) (do-drop (string->number (send x-field get-value))
                                                               (string->number (send y-field get-value))
                                                               (string->number (send radius-field get-value))
                                                               (string->number (send height-field get-value)))))
                                             (stretchable-width #f) (stretchable-height #t))

(send gl gl-init)
(send win show #t)